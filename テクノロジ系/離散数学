基礎理論
  離散数学（情報機器の基本的な仕組みの２進数と論理演算について学習）
         （プログラム実行時での応用、エラー解析に役立てる）
    基数
    基数の変換
    数値の表現
    算術演算と精度
    集合
    論理演算の基本法則

目標
  上記の
    コンピュータで扱う数値表現
    集合、論理演算の基本法則、手法
  を習得する

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー


数と表現
  ２進数
    コンピュータ
      ０、１
  １０進数
    実世界 
      ０〜９
  ８進数
    ０〜７で表現
  １６進数
    ０〜Fで表現する
      ０〜９＋ABCDEF
  基数
    ２（進数）、１０（進数）などの数値
  重み 
    各行にある乗（じょう）のこと

２進数　＝＞　１０進数への変換
  1101を10進数にする
    2 進数 は 0 と 1 の、 2 つの数字だけで数値を表します。
    10 進数の各桁に 10 倍の重みがあるように、 2 進数の各桁にもそれぞれ 2 倍の重みがあります。 2 進数の基数は 2 です。
      １１０１　＝　１＊２（３乗）＋１＊２（２乗）＋０＊２（１乗）＋１＊２（０乗）
                　１＊８　＋　１＊４　＋　０＊２　＋　１＊１　＝１３（１０進数）

１０進数　＝＞　２進数への変換
  13を2進数にする
    13/2 = 6あまり1
    6/2  = 3あまり0
    3/2  = 1あまり1
    1/2  = 0あまり1
      結果、あまりの下から 1101(２進数）　になる

  私たちが普段使用しているのは 10 進数です。 0～9 の、 10 種類の数字を使って数値を表します。
  「４２３円」 と書けば、 百円硬貨 4 枚、 10 円硬貨 2 枚と 1 円硬貨 3 枚の、 「四百二十三円」 のことです。
   10 進数の各桁には、それぞれ 10(2乗、10(1乗、10(0乗 の重みがあるからです （この 10 を 「基数」 といいます）。
    ４２３　＝　４＊１０（２乗）＋２＊１０（１乗）＋３＊１０（０乗）
              ４＊１００　＋　２＊１０　＋　３＊１　＝　４２３

  
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
  
ビット、バイト
  ２進数の１桁での情報量をビット
    ８ビット＝１バイト
  表現可能な数値の範囲
    nビット　＝＞　２(n乗)-1個
      例えば、
        3ビット　＝＞　２（３乗）＝８個
      2(2)=2×2=4
      2(4)=2(2)×2(2)=4×4=16
      2(8)=2(4)×2(4)=16×16=256
      2(16)=2(8)×2(8)=256×256=65536
      たった４回のかけ算で計算できました！
    
８進数
  ０〜７までは普通だが
    数字が８になるときに桁上がりする
      ７（１０進数）　＝＞　７（８進数）
      ８　＝＞　１０
      ９　＝＞　１１
      １５　＝＞　１７
      １６　＝＞　２０

１０進数への変換
  １６進数の場合：
    １６進数                  ０    １    F     A
    重み（基数に乗していく）   16(3) 16(2) 16(1) 16(0)
    -----------------------------------------------
    １０進数              0*16(3) + 1*16(2) + 15*16(1) + 10*16(0)
                        0*4096 + 1*256 + 15*16 + 10*1 = 506(１０進数)


１０進数から各基数への変換
  １６進数の場合：506(10進数)
    506/16 = 31あまり10
    31/16  = 1あまり15
    1/16   = 0あまり1
      結果、あまりの下から  1FA  の１６進数になる
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

２進数の足し算
  ５＋７の場合；
  １０進数　　　　　２進数（２になったら桁上がりする）
    ５　　＝    ０    １    ０    １
    ７　　＝    ０    １    １    １
    １２　＝　  １    １    ０    ０

２進数のマイナスの表現方法
  １ビット目で表現する（1のときがマイナス、０の時がプラス）
    １（１ビット目）10000101は-123
  マイナスに変換する手順
    123 = 0 0 1 1 1 1 0 1 1
    ①0と1を入れ替える
      1 1 0 0 0 0 1 0 0
    ②①の値に+1する
      1 1 0 0 0 0 1 0 1 = -123
  ２進数で123と-123を足し算すると0になる
    0 0 1 1 1 1 0 1 1
    1 1 0 0 0 0 1 0 1
    -----------------
    0 0 0 0 0 0 0 0 0  => ２進数で桁上がりするから



ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

２進数の小数（固定少数点数）
  1 1 1 1 . 1 1 1 1
  整数部
    重みは整数
      1 1 1 1 .
      2(3) 2(2) 2(1) 2(0)
  少数部
    重みはマイナス乗になる
      . 1 1 1 1
      2(-1) 2(-2) 2(-3) 2(-4)


２進数の小数（浮動小数点数）
  小数を  符号  ＊  仮数  ＊  2(指標乗) で表現する
  符号部
    s
  指数部
    E
  仮数部
    M
  EとMに数値を当てはめるには「正規化」を行う必要がある

  単精度浮動小数点
    符号部(1bits),指数部(8bits),仮数部(23bits) = 32bits
  倍精度浮動小数点
    符号部(1bits),指数部(11bits),仮数部(52bits) = 64bits


BCD
  Binary Coded Decimal : ２進化１０進
  １０進数と２進数の中間的な数値の表現方法
    電話番号みたいにして人が見やすくした書き方
  189 = 0001  1000  1001

パック１０進数
  BCDで定義された数値の表現
    １桁の数値を４ビットで表現する
    右端の４ビットは正負の符号を表す
      正：1100
      負：1101
    桁数が偶数の時は、左端に0000を入れる
      （データを整数バイトで表せるようにする）
      512     =>            0101  0001  0010  1100
      -123    =>            0001  0010  0000  1101
      1234    => 0000 0001  0010  0011  0100  1100
      -2456   => 0000 0010  0100  0101  0110  1101
                                             ------
                                             正負
                -------------------------------------
                偶数になるように必要であれば0000を左端に入れる


ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー


論理シフト
  符号を気にせず、２進数のビット列を左や右にずらす
  空いたビット列には０を入れる
算術シフト
  符号を気にして、２進数のビット列を左や右にずらす
    左に移動する場合
      符号ビットは動かさない
    右に移動する場合
      空いた場所に符号ビットを入れる

シフト演算子
  シフトを右にひとつずらす　＝＞  数値を２で割る
  シフトを左にひとつずらす　＝＞　数値を２倍する


ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー


精度（金融系のシステムを作るときに考える）
  丸め誤差
    小数点以下の桁数の長い値を限られた数で近似することで生じる誤差
  情報落ち
    絶対値の大きな値と小さな値の演算で小さな値が切り捨てられることで生じる誤差
  桁落ち
    値の近い２つの値を減算したときに、実際の値との差異が大きくなってしまう現象
  打ち切り
    無限級数を計算する場合に生じる誤差


ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

集合
ベン図
  集合と集合に含まれる要素を表した図

  NOT
  AND
  OR
  XOR（両方に所属しない）


ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

